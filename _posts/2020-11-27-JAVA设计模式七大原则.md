---
title: JAVA设计模式七大原则
date: 2020-11-27 15:56:09 +0800
tags: [JAVA][设计模式]
pin: true
---

[TOC]

## 什么是设计模式

设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性

```
1995年，GoF（Gang of Four,四人组/四人帮）合作出版了《设计模式：可复用面向对象软 件的基础》一书，收录了23种设计模式，从此树立了软件设计模式领域的里程碑，【GoF设计模式】
```



## 为什么要学习设计模式

<B> 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解  </B>



## 设计模式的七大原则

### （一）开闭原则

**定义：软件实体应当对扩展开放，对修改关闭**

我们在开发任何产品的时候，别指望需求是一定不变的，当你不得不更改的你的代码的时候，一个高质量的程序就体现出其价值了，它只需要在原来的基础上增加一些扩展，而不至于去修改原先的代码，因为这样的做法常常会牵一发而动全身。

**也就是说，开闭原则要求我们在开发一个软件（模块）的时候，要保证可以在不修改原有代码的模块的基础上，然后能扩展其功能**



### （二）里氏替换原则

**定义：继承必须确保超类所拥有的性质在子类中仍然成立**

其核心主要有这么四点内容：

-  子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
-  子类中可以增加自己特有的方法
-  当子类的方法重载父类的方法时，子类方法的前置条件（即方法的输入参数）要比父类的方法更宽松
-  当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等



### （三）依赖倒置

**定义：**

- **① 高层模块不应该依赖低层模块，两者都应该依赖其抽象**
- **② 抽象不应该依赖细节，细节应该依赖抽象**

依赖倒置原则的主要作用如下。

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。



### （四）单一职责原则

**定义：单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分**

一个类，并不应该承担太多的责任，否则当为了引入类中的 A 职责的时候，就不得不把 B 职责 也引入，所以我们必须满足其高内聚以及细粒度

优点：

- 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
- 提高类的可读性。复杂性降低，自然其可读性会提高。
- 提高系统的可维护性。可读性提高，那自然更容易维护了。
- 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。



### （五）接口隔离原则

**定义：**

- **客户端不应该被迫依赖于它不使用的方法**
- **或者——客户端不应该被迫依赖于它不使用的方法**

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。



### （六）迪米特法则

**定义：如果两个类不必要彼此直接通讯，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用**

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

### （七）合成复用原则

**定义：在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现**

这一点和里氏替换原则的目的是一致的，都是处理关于继承的内容，本质都是实现了开闭原则的具体规范

通常类的复用分为<font color=red>继承复用</font>和<font color=red>合成复用</font>两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。

1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

**为什么用组合/聚合，不用继承**

- 继承破坏了类的封装性，因为父类对于子类是透明的，而组合/聚合则不会
- 继承父子类之间之间的耦合度比组合/聚合新旧类高
- 从父类继承来的实现是静态的，运行时不会发生变化，而组合/聚合的复用灵活性高，复用可在运行时动态进行



> 参考文献：http://c.biancheng.net/view/1317.html、https://juejin.cn/post/6887718131607797773

